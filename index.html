<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title></title>
  <link href="https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css" rel="stylesheet">
  <style>
    .logo {
      font: 64pt serif;
    }
  </style>
</head>
<body>
  <h2 class="logo text-center p-4 bg-black text-white">treasurer</h2>
  <div class="mx-auto max-w-5xl p-2">
    <div class="py-4 px-3">
      <h1 class="inline text-5xl">The Mint</h1>
      <p class="inline ml-3 text-lg">Mint an audio coin visualization.</p>
    </div>
    <p class="px-3 py-2">
      We used this tool to generate all of the video for our first E.P. <a class="underline" href="https://treasurer.bandcamp.com/album/compass">Compass</a>.
      We released this tool so that you could make your own audio coin (a Circular Spectrogram really) from you own tracks to use in your own videos and visualizers.
    </p>

    <div class="py-4 px-3 text-lg">
      <div>
        <label for="">
          <span class="font-bold">Artist Name: </span>
          <input class="max-w-xl" type="text" id="artist" value="treasurer" placeholder="artist name">
        </label>
        <label for="">
          <span class="font-bold">Track Name: </span>
          <input class="max-w-xl" type="text" id="track" value="the quiet" placeholder="track name">
        </label>
        <button id="update" class="hover:bg-gray-700 px-3 py-2 text-white bg-black rounded">Update</button>
      </div>
    </div>

    <div class="relative group">
      <video id="video" class="w-full bg-black" muted autoplay></video>
      <div id="upload" class="opacity-0 group-hover:opacity-100 absolute inset-0 text-xl text-white flex justify-center items-center">Load an Audio File</div>
    </div>

    <input class="hidden" id="file" type="file">


    <div class="py-4 flex justify-center">
      <a class="px-4 py-3 bg-gray-300 text-white rounded cursor-not-allowed" id="download">Download</a>
    </div>
  </div>
  <script>
    function setController(element, attributes) {
      for (let attr in attributes)
        element[attr] = attributes[attr]

      return element
    }

    function readFile(file, callback) {
      let reader = new FileReader(file)
      reader.onload = function (e) { callback(e.target.result) }
      reader.readAsArrayBuffer(file)
    }

    let audio = setController(new (AudioContext || WebkitAudioContext)(), {
      startedAt: null,
      init() {
        this.analyser = this.createAnalyser()
        this.recorderDestination = this.createMediaStreamDestination()
        this.silence = this.createBufferSource()
        this.source = this.createBufferSource()
        this.source.connect(this.analyser)
        this.source.connect(this.destination)
        this.source.connect(this.recorderDestination)
        this.silence.connect(this.recorderDestination)
      },
      start() {
        this.startedAt = this.currentTime
        audio.source.start()
      },
      position() {
        return this.currentTime - this.startedAt
      }
    })
    audio.init()

    let artist = setController(document.getElementById('artist') ,{
      onchange(e) {
        visualizer.drawText(this)
      },
      color: 'rgb(255,255,255)',
      font: '120px serif',
      x(context, size) {
        return 3 * (context.width/4) - (size.width/2)
      },
      y(context) {
        return (context.height/2) - 100
      }
    })

    let track = setController(document.getElementById('track'), {
      onchange(e) {
        visualizer.drawText(this)
      },
      color: 'rgb(255,255,255)',
      font: '200px serif',
      x(context, size) {
        return 3 * (context.width/4) - (size.width/2)
      },
      y(context) {
        return (context.height/2) + (200/2)
      }
    })

    let update = setController(document.getElementById('update'), {
      onclick(e) {
        visualizer.clear()
        visualizer.drawText(artist)
        visualizer.drawText(track)
      }
    })

    let visualizer = setController(document.createElement('canvas'), {
      init() {
        this.scale = window.devicePixelRatio
        this.width = Math.floor(1080 * this.scale)
        this.height = Math.floor(720 * this.scale)
        this.context = this.getContext('2d')

        this.clear()
        this.drawText(artist)
        this.drawText(track)

        this.stream = visualizer.captureStream()
      },
      clear() {
        // setup the static areas of the video
        this.context.fillStyle = 'rgb(0,0,0)'
        this.context.fillRect(0, 0, this.width, this.height)
      },
      drawText(text) {
        this.context.fillStyle = text.color
        this.context.font = text.font
        let size = this.context.measureText(text.value)

        this.context.fillStyle = 'rgb(0,0,0)'
        this.context.fillRect(text.x(this, size), text.y(this, size), size.width, size.height)

        this.context.fillStyle = text.color
        this.context.font = text.font
        this.context.fillText(text.value, text.x(this, size), text.y(this, size))
      }
    })
    visualizer.init()

    const worker = setController(new Worker('worker.js'), {
      stopped: false,
      stop() { this.stopped = true },
      async onmessage(e) {
        if (e.data.image) {
          let width = 4 * visualizer.height / 5
          let bitmap = await createImageBitmap(e.data.image, {
            resizeWidth: width,
            resizeHeight: width
          })
          visualizer.context.drawImage(
            bitmap,
            100 + visualizer.width/4 - bitmap.width/2,
            visualizer.height/2 - bitmap.height/2
          )
        }

        if (!this.stopped) {
          let fft = new Uint8Array(audio.analyser.frequencyBinCount)
          audio.analyser.getByteFrequencyData(fft)
          worker.postMessage({
            fft: fft,
            duration: audio.source.buffer?.duration,
            position: audio.position()
          })
        }
      }
    })

    const file = setController(document.getElementById('file'), {
      onchange(event) {
        upload.classList.remove('group-hover:opacity-100')

        this.audioFile = event.target.files[0]

        readFile(this.audioFile, (buffer) => {
          audio.decodeAudioData(buffer, (audioBuffer) => {
            let timeslice = 1000 + (audioBuffer.duration * 1000)
            recorder.start(timeslice)
            audio.source.buffer = audioBuffer
            audio.start()
            console.log(audio.startedAt)
            video.muted = false
          })
        })
        
        let canvas = new OffscreenCanvas(
          visualizer.height,
          visualizer.height,
        )
        worker.postMessage({ scale: visualizer.scale, canvas }, [canvas])
      }
    })

    const upload = setController(document.getElementById('upload'), {
      ondragover: (e) => e.preventDefault(),
      ondragenter: (e) => e.preventDefault(),
      onclick: (e) => file.click(),
      ondrop: (e) => {
        const dataTransfer = new DataTransfer()
        dataTransfer.items.add(e.dataTransfer.files[0])
        file.files = dataTransfer.files

        e.preventDefault()
      } 
    })

    const download = setController(document.getElementById('download'), {
      enable() {
        this.classList.remove('cursor-not-allowed', 'bg-gray-300')
        this.classList.add('bg-black', 'hover:bg-gray-700')
        this.disabled = false
      },
      disable() {
        this.classList.add('cursor-not-allowed', 'bg-gray-300')
        this.classList.remove('bg-black', 'hover:bg-gray-700')
        this.disabled = true
      }
    })

    let video = setController(document.getElementById('video'), {
      srcObject: visualizer.stream
    })

    let mediaStream = new MediaStream([
      visualizer.stream.getVideoTracks()[0],
      audio.recorderDestination.stream.getAudioTracks()[0]
    ])

    const recorder = setController(
      new MediaRecorder(mediaStream, { mimeType: 'video/webm' }),
      {
        chunks: [],
        ondataavailable(event) {
          this.chunks.push(event.data)

          if (this.state === 'recording')
            this.stop()
        },
        onstop(event) {
          worker.stop()
          let blob = new Blob(this.chunks, { type: 'video/webm' })
          let url = URL.createObjectURL(blob)
          let name = [artist.value, track.value || file.audioFile.name].filter(Boolean).join(' ')
          download.download = `${name}.webm`
          download.href = url
          download.enable()
        }
      }
    )
  </script>
</body>
</html>
